import{M as Z,s as d,V as q}from"./index-DD9VVSMx.js";import{c as R,P as i,B as f,G as _,M as I,U as b,L as m,D as J,V as F}from"./enums-CxXC-vJk.js";const Q=()=>q.getLogger("esri.views.webgl.checkWebGLError");function ee(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const v=!!Z("enable-feature:webgl-debug");function te(){return v}function ge(){return v}function D(t){if(te()){const e=t.getError();if(e){const r=ee(t,e),a=new Error().stack;Q().error(new d("webgl-error","WebGL error occurred",{message:r,stack:a}))}}}var C;(function(t){t[t.Texture=0]="Texture",t[t.RenderBuffer=1]="RenderBuffer"})(C||(C={}));function re(t){switch(t){case _.ALPHA:case _.LUMINANCE:case _.RED:case _.RED_INTEGER:case i.R8:case i.R8I:case i.R8UI:case i.R8_SNORM:case f.STENCIL_INDEX8:return 1;case _.LUMINANCE_ALPHA:case _.RG:case _.RG_INTEGER:case i.RGBA4:case i.R16F:case i.R16I:case i.R16UI:case i.RG8:case i.RG8I:case i.RG8UI:case i.RG8_SNORM:case i.RGB565:case i.RGB5_A1:case f.DEPTH_COMPONENT16:return 2;case _.DEPTH_COMPONENT:case _.RGB:case _.RGB_INTEGER:case i.RGB8:case i.RGB8I:case i.RGB8UI:case i.RGB8_SNORM:case i.SRGB8:case f.DEPTH_COMPONENT24:return 3;case _.DEPTH_STENCIL:case _.DEPTH24_STENCIL8:case _.RGBA:case _.RGBA_INTEGER:case i.RGBA8:case i.R32F:case i.R11F_G11F_B10F:case i.RG16F:case i.R32I:case i.R32UI:case i.RG16I:case i.RG16UI:case i.RGBA8I:case i.RGBA8UI:case i.RGBA8_SNORM:case i.SRGB8_ALPHA8:case i.RGB9_E5:case i.RGB10_A2UI:case i.RGB10_A2:case f.DEPTH_STENCIL:case f.DEPTH_COMPONENT32F:case f.DEPTH24_STENCIL8:return 4;case f.DEPTH32F_STENCIL8:return 5;case i.RGB16F:case i.RGB16I:case i.RGB16UI:return 6;case i.RG32F:case i.RG32I:case i.RG32UI:case i.RGBA16F:case i.RGBA16I:case i.RGBA16UI:return 8;case i.RGB32F:case i.RGB32I:case i.RGB32UI:return 12;case i.RGBA32F:case i.RGBA32I:case i.RGBA32UI:return 16;case R.COMPRESSED_RGB_S3TC_DXT1_EXT:case R.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case R.COMPRESSED_RGBA_S3TC_DXT3_EXT:case R.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case R.COMPRESSED_R11_EAC:case R.COMPRESSED_SIGNED_R11_EAC:case R.COMPRESSED_RGB8_ETC2:case R.COMPRESSED_SRGB8_ETC2:case R.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case R.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case R.COMPRESSED_RG11_EAC:case R.COMPRESSED_SIGNED_RG11_EAC:case R.COMPRESSED_RGBA8_ETC2_EAC:case R.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}let se=class{constructor(e=0,r=e){this.width=e,this.height=r,this.target=I.TEXTURE_2D,this.pixelFormat=_.RGBA,this.dataType=b.UNSIGNED_BYTE,this.samplingMode=m.LINEAR,this.wrapMode=J.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.depth=1,this.isImmutable=!1}};function ie(t){return t.width<=0||t.height<=0?0:Math.round(t.width*t.height*(t.hasMipmap?4/3:1)*(t.internalFormat==null?4:re(t.internalFormat)))}let ae=class H extends se{constructor(e,r){switch(super(),this.context=e,Object.assign(this,r),this.internalFormat){case i.R16F:case i.R16I:case i.R16UI:case i.R32F:case i.R32I:case i.R32UI:case i.R8_SNORM:case i.R8:case i.R8I:case i.R8UI:this.pixelFormat=_.RED}}static validate(e,r){return new H(e,r)}};const B=4;let ne=class A{constructor(e,r=null,a=null){if(this.type=C.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,a=r;else{const s=ae.validate(e,r);if(!s)throw new d("Texture descriptor invalid");this._descriptor=s}this._descriptor.target===I.TEXTURE_CUBE_MAP?this._setDataCubeMap(a):this.setData(a)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return ie(this._descriptor)}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._glName&&this._descriptor.context.instanceCounter.decrement(F.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,r){const a=this._descriptor;if(a.width!==e||a.height!==r){if(this._wasImmutablyAllocated)throw new d("Immutable textures can't be resized!");a.width=e,a.height=r,this._descriptor.target===I.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(e=null){for(let r=I.TEXTURE_CUBE_MAP_POSITIVE_X;r<=I.TEXTURE_CUBE_MAP_NEGATIVE_Z;r++)this._setData(e,r)}setData(e){this._setData(e)}_setData(e,r){var u;if(!((u=this._descriptor.context)!=null&&u.gl))return;const a=this._descriptor.context.gl;D(a),this._glName||(this._glName=a.createTexture(),this._glName&&this._descriptor.context.instanceCounter.increment(F.Texture,this)),e===void 0&&(e=null);const s=this._descriptor,n=r??s.target,c=N(n);e===null&&(s.width=s.width||B,s.height=s.height||B,c&&(s.depth=s.depth??1));const l=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),P(s),this._configurePixelStorage(),D(a);const o=this._deriveInternalFormat();if(y(e)){let E="width"in e?e.width:e.codedWidth,h="height"in e?e.height:e.codedHeight;const p=1;e instanceof HTMLVideoElement&&(E=e.videoWidth,h=e.videoHeight),s.width&&s.height,c&&s.depth,s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,o,s.hasMipmap,E,h,p),this._texImage(n,0,o,E,h,p,e),D(a),s.hasMipmap&&this.generateMipmap(),s.width||(s.width=E),s.height||(s.height=h),c&&!s.depth&&(s.depth=p)}else{const{width:E,height:h,depth:p}=s;if(E==null||h==null)throw new d("Width and height must be specified!");if(c&&p==null)throw new d("Depth must be specified!");if(s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(n,o,s.hasMipmap,E,h,p),w(e)){const T=e.levels,x=X(n,E,h,p),M=Math.min(x-1,T.length-1);a.texParameteri(s.target,this._descriptor.context.gl.TEXTURE_MAX_LEVEL,M);const g=o;if(!le(g))throw new d("Attempting to use compressed data with an uncompressed format!");this._forEachMipmapLevel((S,G,K,k)=>{const j=T[Math.min(S,T.length-1)];this._compressedTexImage(n,S,g,G,K,k,j)},M)}else this._texImage(n,0,o,E,h,p,e),D(a),s.hasMipmap&&this.generateMipmap()}O(a,this._descriptor),L(a,this._descriptor),oe(this._descriptor.context,this._descriptor),D(a),this._descriptor.context.bindTexture(l,A.TEXTURE_UNIT_FOR_UPDATES)}updateData(e,r,a,s,n,c,l=0){c||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const o=this._descriptor,u=this._deriveInternalFormat(),{context:E,pixelFormat:h,dataType:p,target:T,isImmutable:x}=o;if(x&&!this._wasImmutablyAllocated)throw new d("Cannot update immutable texture before allocation!");const M=E.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||a<0||r+s>o.width||a+n>o.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:g}=E;l&&g.pixelStorei(g.UNPACK_SKIP_ROWS,l),y(c)?g.texSubImage2D(T,e,r,a,s,n,h,p,c):w(c)?g.compressedTexSubImage2D(T,e,r,a,s,n,u,c.levels[e]):g.texSubImage2D(T,e,r,a,s,n,h,p,c),l&&g.pixelStorei(g.UNPACK_SKIP_ROWS,0),E.bindTexture(M,A.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,r,a,s,n,c,l,o){o||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const u=this._descriptor,E=this._deriveInternalFormat(),{context:h,pixelFormat:p,dataType:T,isImmutable:x,target:M}=u;if(x&&!this._wasImmutablyAllocated)throw new d("Cannot update immutable texture before allocation!");N(M)||console.warn("Attempting to set 3D texture data on a non-3D texture");const g=h.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);h.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),(r<0||a<0||s<0||r+n>u.width||a+c>u.height||s+l>u.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:S}=h;if(w(o))o=o.levels[e],S.compressedTexSubImage3D(M,e,r,a,s,n,c,l,E,o);else{const G=o;S.texSubImage3D(M,e,r,a,s,n,c,l,p,T,G)}h.bindTexture(g,A.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new d("Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,P(e)}e.samplingMode===m.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=m.LINEAR_MIPMAP_NEAREST):e.samplingMode===m.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=m.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,A.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(A.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(r,A.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new d("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,P(e)}e.samplingMode===m.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=m.LINEAR):e.samplingMode===m.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=m.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,P(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const e=this._descriptor,r=e.context.gl;this._samplingModeDirty&&(O(r,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(L(r,e),this._wrapModeDirty=!1)}_deriveInternalFormat(){if(this._descriptor.internalFormat!=null)return this._descriptor.internalFormat===_.DEPTH_STENCIL&&(this._descriptor.internalFormat=_.DEPTH24_STENCIL8),this._descriptor.internalFormat;switch(this._descriptor.dataType){case b.FLOAT:switch(this._descriptor.pixelFormat){case _.RGBA:return this._descriptor.internalFormat=i.RGBA32F;case _.RGB:return this._descriptor.internalFormat=i.RGB32F;default:throw new d("Unable to derive format")}case b.UNSIGNED_BYTE:switch(this._descriptor.pixelFormat){case _.RGBA:return this._descriptor.internalFormat=i.RGBA8;case _.RGB:return this._descriptor.internalFormat=i.RGB8}}return this._descriptor.internalFormat=this._descriptor.pixelFormat===_.DEPTH_STENCIL?_.DEPTH24_STENCIL8:this._descriptor.pixelFormat}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:r,flipped:a,preMultiplyAlpha:s}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,r),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,a?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s?1:0)}_texStorage(e,r,a,s,n,c){const{gl:l}=this._descriptor.context;if(!ce(r))throw new d("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const o=a?X(e,s,n,c):1;if(N(e)){if(c==null)throw new d("Missing depth dimension for 3D texture upload");l.texStorage3D(e,o,r,s,n,c)}else l.texStorage2D(e,o,r,s,n);this._wasImmutablyAllocated=!0}_texImage(e,r,a,s,n,c,l){const o=this._descriptor.context.gl,u=N(e),{isImmutable:E,pixelFormat:h,dataType:p}=this._descriptor;if(E){if(l!=null){const T=l;if(u){if(c==null)throw new d("Missing depth dimension for 3D texture upload");o.texSubImage3D(e,r,0,0,0,s,n,c,h,p,T)}else o.texSubImage2D(e,r,0,0,s,n,h,p,T)}}else{const T=l;if(u){if(c==null)throw new d("Missing depth dimension for 3D texture upload");o.texImage3D(e,r,a,s,n,c,0,h,p,T)}else o.texImage2D(e,r,a,s,n,0,h,p,T)}}_compressedTexImage(e,r,a,s,n,c,l){const o=this._descriptor.context.gl,u=N(e);if(this._descriptor.isImmutable){if(l!=null)if(u){if(c==null)throw new d("Missing depth dimension for 3D texture upload");o.compressedTexSubImage3D(e,r,0,0,0,s,n,c,a,l)}else o.compressedTexSubImage2D(e,r,0,0,s,n,a,l)}else if(u){if(c==null)throw new d("Missing depth dimension for 3D texture upload");o.compressedTexImage3D(e,r,a,s,n,c,0,l)}else o.compressedTexImage2D(e,r,a,s,n,0,l)}_forEachMipmapLevel(e,r=1/0){let{width:a,height:s,depth:n,hasMipmap:c,target:l}=this._descriptor;const o=l===I.TEXTURE_3D;if(a==null||s==null||o&&n==null)throw new d("Missing texture dimensions for mipmap calculation");for(let u=0;e(u,a,s,n),c&&(a!==1||s!==1||o&&n!==1)&&!(u>=r);++u)a=Math.max(1,a>>1),s=Math.max(1,s>>1),o&&(n=Math.max(1,n>>1))}};function P(t){(t.width!=null&&t.width<0||t.height!=null&&t.height<0||t.depth!=null&&t.depth<0)&&console.error("Negative dimension parameters are not allowed!")}function O(t,e){let r=e.samplingMode,a=e.samplingMode;r===m.LINEAR_MIPMAP_NEAREST||r===m.LINEAR_MIPMAP_LINEAR?(r=m.LINEAR,e.hasMipmap||(a=m.LINEAR)):r!==m.NEAREST_MIPMAP_NEAREST&&r!==m.NEAREST_MIPMAP_LINEAR||(r=m.NEAREST,e.hasMipmap||(a=m.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,a)}function L(t,e){typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}function oe(t,e){const r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}function ce(t){return t in i}function le(t){return t in R}function w(t){return t!=null&&"type"in t&&t.type==="compressed"}function _e(t){return t!=null&&"byteLength"in t}function y(t){return t!=null&&!w(t)&&!_e(t)}function N(t){return t===I.TEXTURE_3D||t===I.TEXTURE_2D_ARRAY}function X(t,e,r,a=1){let s=Math.max(e,r);return t===I.TEXTURE_3D&&(s=Math.max(s,a)),Math.round(Math.log(s)/Math.LN2)+1}ne.TEXTURE_UNIT_FOR_UPDATES=0;function $(){return new Float32Array(2)}function he(t){const e=new Float32Array(2);return e[0]=t[0],e[1]=t[1],e}function U(t,e){const r=new Float32Array(2);return r[0]=t,r[1]=e,r}function ue(t,e){return new Float32Array(t,e,2)}function W(){return $()}function V(){return U(1,1)}function z(){return U(1,0)}function Y(){return U(0,1)}const pe=W(),de=V(),Ee=z(),me=Y();Object.freeze(Object.defineProperty({__proto__:null,ONES:de,UNIT_X:Ee,UNIT_Y:me,ZEROS:pe,clone:he,create:$,createView:ue,fromValues:U,ones:V,unitX:z,unitY:Y,zeros:W},Symbol.toStringTag,{value:"Module"}));export{ge as a,te as b,ne as c,se as e,de as f,pe as i,$ as n,U as t,re as u};
