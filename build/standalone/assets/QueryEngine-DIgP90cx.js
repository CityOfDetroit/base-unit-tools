const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/geometryEngineWorker-ClddcLz0.js","assets/geometryEngineBase-RmbNeFm7.js","assets/_commonjsHelpers-DCkdB7M8.js","assets/json-Wa8cmqdu.js"])))=>i.map(i=>d[i]);
import{e as B,a as Mt}from"./OptimizedFeature-DDMKj8Vq.js";import{dt as kt,iy as Vt,ab as v,a2 as Qt,iz as ht,ad as Oe,du as dt,O as Ut,ce as qt,bR as j,dk as Qe,s as b,bF as Ue,dO as Ee,dP as Re,dV as ft,dW as mt,bP as qe,bO as de,iA as ze,_ as Pe,iB as zt,iC as Se,iD as jt,iE as Zt,$ as le,a_ as Bt,dh as Fe,hY as z,az as te,aB as Yt,bp as Ht,iF as Wt,aa as Jt,bD as je,iG as Xt,iH as Kt,iI as es,iJ as ts,aH as ss,fz as pt,bX as oe,bY as is,B as fe,D as Ze,E as rs,bw as as,iK as me,b5 as pe,bx as ns,fx as ls,bU as we,dn as C,V as os,iL as us,by as cs,iM as hs,iN as ds,iO as fs,hX as ms,bE as ps,ft as gs,iP as $,c7 as ys,iQ as _s,b0 as Is,fT as Ts,d3 as ge,b6 as xs,iR as Es,aF as Be,hZ as Rs,b3 as Ss,fR as Fs,b7 as ws}from"./index-CCrAUeKG.js";import{R as be}from"./normalizeUtils-BSbja_dL.js";import{I as bs,x as Ae,$ as As,H as Ns,U as $s,a as Ne,h as vs,K as Ye,o as Cs}from"./featureConversionUtils-BrlJQH4G.js";import{O as Os}from"./WhereClause-BskC5EKl.js";import{t as gt}from"./json-Wa8cmqdu.js";import{t as Ps}from"./QueryEngineCapabilities-CTDe3LlQ.js";import{w as Gs}from"./utils-Dalbwhza.js";import{c as ye,B as Ds,d as He,p as We,C as Ls,k as Ms,$ as ks,E as Vs,P as Qs,U as Us,T as qs,v as zs,f as js}from"./utils-BFegV2YL.js";import{r as $e}from"./signal-BM4bU7od.js";const Je=new B,Zs=new B,ve=new B,G={esriGeometryPoint:Ae,esriGeometryPolyline:As,esriGeometryPolygon:Ns,esriGeometryMultipoint:$s};function _e(s,e,t,r=s.hasZ,a=s.hasM){if(e==null)return null;const i=s.hasZ&&r,n=s.hasM&&a;if(t){const l=Ne(ve,e,s.hasZ,s.hasM,"esriGeometryPoint",t,r,a);return Ae(l,i,n)}return Ae(e,i,n)}function L(s,e,t,r,a,i,n=e,l=t){var h,d,f;const o=e&&n,u=t&&l,c=r!=null?"coords"in r?r:r.geometry:null;if(c==null)return null;if(a){let p=vs(Zs,c,e,t,s,a,n,l);return i&&(p=Ne(ve,p,o,u,s,i)),((h=G[s])==null?void 0:h.call(G,p,o,u))??null}if(i){const p=Ne(ve,c,e,t,s,i,n,l);return((d=G[s])==null?void 0:d.call(G,p,o,u))??null}return bs(Je,c,e,t,n,l),((f=G[s])==null?void 0:f.call(G,Je,o,u))??null}function K(s){return s&&yt in s?JSON.parse(JSON.stringify(s,Bs)):s}const yt="_geVersion",Bs=(s,e)=>s!==yt?e:void 0;function Ge(s,e){return s?e?4:3:e?3:2}function Ys(s,e,t,r){if(!(e!=null&&e.lengths.length))return null;s.lengths.length&&(s.lengths.length=0),s.coords.length&&(s.coords.length=0);const a=s.coords,i=[],n=t?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:l,coords:o}=e,u=Ge(t,r);let c=0;for(const h of l){const d=Hs(n,o,c,h,t,r);d&&i.push(d),c+=h*u}if(i.sort((h,d)=>{let f=h[2]-d[2];return f===0&&t&&(f=h[4]-d[4]),f}),i.length){let h=6*i[0][2];a[0]=i[0][0]/h,a[1]=i[0][1]/h,t&&(h=6*i[0][4],a[2]=h!==0?i[0][3]/h:0),(a[0]<n[0]||a[0]>n[1]||a[1]<n[2]||a[1]>n[3]||t&&(a[2]<n[4]||a[2]>n[5]))&&(a.length=0)}if(!a.length){const h=e.lengths[0]?Ws(o,0,l[0],t,r):null;if(!h)return null;a[0]=h[0],a[1]=h[1],t&&h.length>2&&(a[2]=h[2])}return s}function Hs(s,e,t,r,a,i){const n=Ge(a,i);let l=t,o=t+n,u=0,c=0,h=0,d=0,f=0;for(let m=0,x=r-1;m<x;m++,l+=n,o+=n){const y=e[l],E=e[l+1],S=e[l+2],g=e[o],_=e[o+1],R=e[o+2];let I=y*_-g*E;d+=I,u+=(y+g)*I,c+=(E+_)*I,a&&(I=y*R-g*S,h+=(S+R)*I,f+=I),y<s[0]&&(s[0]=y),y>s[1]&&(s[1]=y),E<s[2]&&(s[2]=E),E>s[3]&&(s[3]=E),a&&(S<s[4]&&(s[4]=S),S>s[5]&&(s[5]=S))}if(d>0&&(d*=-1),f>0&&(f*=-1),!d)return null;const p=[u,c,.5*d];return a&&(p[3]=h,p[4]=.5*f),p}function Ws(s,e,t,r,a){const i=Ge(r,a);let n=e,l=e+i,o=0,u=0,c=0,h=0;for(let d=0,f=t-1;d<f;d++,n+=i,l+=i){const p=s[n],m=s[n+1],x=s[n+2],y=s[l],E=s[l+1],S=s[l+2],g=r?Xs(p,m,x,y,E,S):Js(p,m,y,E);if(g)if(o+=g,r){const _=ei(p,m,x,y,E,S);u+=g*_[0],c+=g*_[1],h+=g*_[2]}else{const _=Ks(p,m,y,E);u+=g*_[0],c+=g*_[1]}}return o>0?r?[u/o,c/o,h/o]:[u/o,c/o]:t>0?r?[s[e],s[e+1],s[e+2]]:[s[e],s[e+1]]:null}function Js(s,e,t,r){const a=t-s,i=r-e;return Math.sqrt(a*a+i*i)}function Xs(s,e,t,r,a,i){const n=r-s,l=a-e,o=i-t;return Math.sqrt(n*n+l*l+o*o)}function Ks(s,e,t,r){return[s+.5*(t-s),e+.5*(r-e)]}function ei(s,e,t,r,a,i){return[s+.5*(r-s),e+.5*(a-e),t+.5*(i-t)]}const tr={getObjectId:s=>s.objectId,getAttributes:s=>s.attributes,getAttribute:(s,e)=>s.attributes[e],cloneWithGeometry:(s,e)=>new Mt(e,s.attributes,null,s.objectId),getGeometry:s=>s.geometry,getCentroid:(s,e)=>(s.centroid==null&&(s.centroid=Ys(new B,s.geometry,e.hasZ,e.hasM)),s.centroid)},Ie=[0,0];function _t(s,e){if(!e)return null;if("x"in e){const t={x:0,y:0};return[t.x,t.y]=s(e.x,e.y,Ie),e.z!=null&&(t.z=e.z),e.m!=null&&(t.m=e.m),t}if("xmin"in e){const t={xmin:0,ymin:0,xmax:0,ymax:0};return[t.xmin,t.ymin]=s(e.xmin,e.ymin,Ie),[t.xmax,t.ymax]=s(e.xmax,e.ymax,Ie),e.hasZ&&(t.zmin=e.zmin,t.zmax=e.zmax,t.hasZ=!0),e.hasM&&(t.mmin=e.mmin,t.mmax=e.mmax,t.hasM=!0),t}return"rings"in e?{rings:Xe(e.rings,s),hasM:e.hasM,hasZ:e.hasZ}:"paths"in e?{paths:Xe(e.paths,s),hasM:e.hasM,hasZ:e.hasZ}:"points"in e?{points:It(e.points,s),hasM:e.hasM,hasZ:e.hasZ}:null}function Xe(s,e){const t=[];for(const r of s)t.push(It(r,e));return t}function It(s,e){const t=[];for(const r of s){const a=e(r[0],r[1],[0,0]);t.push(a),r.length>2&&a.push(r[2]),r.length>3&&a.push(r[3])}return t}async function H(s,e){if(!s||!e)return;const t=Array.isArray(s)?s.map(r=>r.geometry!=null?r.geometry.spatialReference:null).filter(Ut):[s];await qt(t.map(r=>({source:r,dest:e})))}const Tt=_t.bind(null,kt),xt=_t.bind(null,Vt);function D(s,e,t,r){if(!s||(t||(t=e,e=s.spatialReference),!j(e)||!j(t)||v(e,t)))return s;if(ht(e,t)){const a=Oe(t)?Tt(s):xt(s);return a.spatialReference=t,a}return dt(gt,[s],e,t,null,r)[0]}class ti{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,r,a){if(!(e!=null&&e.length)||!t||!r||v(t,r))return e;const i={geometries:e,inSpatialReference:t,outSpatialReference:r,geographicTransformation:a,resolve:Qt()};return this._jobs.push(i),this._timer??(this._timer=setTimeout(this._process,10)),i.resolve.promise}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:r,outSpatialReference:a,resolve:i,geographicTransformation:n}=e;ht(r,a)?Oe(a)?i(t.map(Tt)):i(t.map(xt)):i(dt(gt,t,r,a,n,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const si=new ti;function ii(s,e,t,r){return si.push(s,e,t,r)}let ri=class{constructor(e,t){this._cache=new Qe(e),this._invalidCache=new Qe(t)}get(e,t){const r=`${t.uid}:${e}`,a=this._cache.get(r);if(a)return a;if(this._invalidCache.get(r)!=null)return null;try{const i=Os.create(e,t);return this._cache.put(r,i),i}catch(i){return this._invalidCache.put(r,i),null}}getError(e,t){const r=`${t.uid}:${e}`;return this._invalidCache.get(r)??null}};const Et=new ri(50,500),ee="unsupported-query",Rt=" as ",St=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeBigInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong"]),Ft=new Set(["esriFieldTypeDate","esriFieldTypeDateOnly","esriFieldTypeTimeOnly","esriFieldTypeTimestampOffset"]),ai=new Set(["esriFieldTypeString","esriFieldTypeGUID","esriFieldTypeGlobalID",...St,...Ft]);function De(s,e,t={}){const r=q(e,s);if(!r){const i=Et.getError(e,s);throw new b(ee,"invalid SQL expression",{expression:e,error:i})}const a=t.expressionName||"expression";if(t.validateStandardized&&!r.isStandardized)throw new b(ee,`${a} is not standard`,{expression:e});if(t.validateAggregate&&!r.isAggregate)throw new b(ee,`${a} does not contain a valid aggregate function`,{expression:e});return r.fieldNames}function ni(s,e,t,r){if(!t)return!0;const a="where clause";return Q(s,e,De(s,t,{validateStandardized:!0,expressionName:a}),{expressionName:a,query:r}),!0}function li(s,e,t,r,a){if(!t)return!0;const i="having clause",n=De(s,t,{validateAggregate:!0,expressionName:i});Q(s,e,n,{expressionName:i,query:a});const l=q(t,s);if(!(l==null?void 0:l.getExpressions().every(u=>{var f;const{aggregateType:c,field:h}=u,d=(f=s.get(h))==null?void 0:f.name;return r.some(p=>{var E;const{onStatisticField:m,statisticType:x}=p;return((E=s.get(m))==null?void 0:E.name)===d&&x.toLowerCase().trim()===c})})))throw new b(ee,"expressions in having clause should also exist in outStatistics",{having:t});return!0}function q(s,e){return s?Et.get(s,e):null}function wt(s){return/\((.*?)\)/.test(s)?s:s.split(Rt)[0]}function oi(s){return s.split(Rt)[1]}function Q(s,e,t,r={}){const a=new Map;if(ui(a,s,e,r.allowedFieldTypes??ai,t),a.size){const i=r.expressionName??"expression";throw new b(ee,`${i} contains invalid or missing fields`,{errors:Array.from(a.values()),query:r.query})}}function ui(s,e,t,r,a){const i=a.includes("*")?[...t,...a.filter(n=>n!=="*")]:a;for(const n of i)if(e.get(n))Ke(s,e,t,r,n);else try{const l=De(e,wt(n),{validateStandardized:!0});for(const o of l)Ke(s,e,t,r,o)}catch(l){s.set(n,{type:"expression-error",expression:n,error:l})}}function Ke(s,e,t,r,a){const i=e.get(a);i?t.has(i.name)?r!=="all"&&(r==null?void 0:r.has(i.type))===!1&&s.set(a,{type:"invalid-type",fieldName:i.name,fieldType:Ue.fromJSON(i.type),allowedFieldTypes:Array.from(r,n=>Ue.fromJSON(n))}):s.set(a,{type:"missing-field",fieldName:i.name}):s.set(a,{type:"invalid-field",fieldName:a})}let ne=class{constructor(e,t,r){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues??!1,this.fieldsIndex=r,this.featureAdapter=t;const a=e.outFields;if(a&&!a.includes("*")){this.outFields=a;let i=0;for(const n of a){const l=wt(n),o=this.fieldsIndex.get(l),u=o?null:q(l,r),c=o?o.name:oi(n)||"FIELD_EXP_"+i++;this._fieldDataCache.set(n,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,r){var n;const a=r?r.name:t;let i=null;return this._fieldDataCache.has(a)?i=(n=this._fieldDataCache.get(a))==null?void 0:n.clause:r||(i=q(t,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:i})),r?this.featureAdapter.getAttribute(e,a):i==null?void 0:i.calculateValue(e,this.featureAdapter)}getDataValues(e,t,r=!0){const a=t.normalizationType,i=t.normalizationTotal,n=this.fieldsIndex.get(t.field),l=Ee(n)||Re(n),o=ft(n);return e.map(u=>{let c=t.field&&this.getFieldValue(u,t.field,this.fieldsIndex.get(t.field));if(t.field2?(c=`${ye(c)}${t.fieldDelimiter}${ye(this.getFieldValue(u,t.field2,this.fieldsIndex.get(t.field2)))}`,t.field3&&(c=`${c}${t.fieldDelimiter}${ye(this.getFieldValue(u,t.field3,this.fieldsIndex.get(t.field3)))}`)):typeof c=="string"&&r&&(l?c=c?new Date(c).getTime():null:o&&(c=c?Gs(c):null)),a&&Number.isFinite(c)){const h=a==="field"&&t.normalizationField?this.getFieldValue(u,t.normalizationField,this.fieldsIndex.get(t.normalizationField)):null;c=Ds(c,a,h,i)}return c})}async getExpressionValues(e,t,r,a,i){const{arcadeUtils:n}=await mt(),l=n.hasGeometryOperations(t);l&&await n.enableGeometryOperations();const o=n.createFunction(t),u=n.getViewInfo(r),c={fields:this.fieldsIndex.fields};return e.map(h=>{const d={attributes:this.featureAdapter.getAttributes(h),layer:c,geometry:l?{...L(a.geometryType,a.hasZ,a.hasM,this.featureAdapter.getGeometry(h)),spatialReference:r==null?void 0:r.spatialReference}:null},f=n.createExecContext(d,u,i);return n.executeFunction(o,f)})}validateItem(e,t){var r,a;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:q(t,this.fieldsIndex)}),((a=(r=this._fieldDataCache.get(t))==null?void 0:r.clause)==null?void 0:a.testFeature(e,this.featureAdapter))??!1}validateItems(e,t){var r,a;return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:q(t,this.fieldsIndex)}),((a=(r=this._fieldDataCache.get(t))==null?void 0:r.clause)==null?void 0:a.testSet(e,this.featureAdapter))??!1}_processAttributesForOutFields(e){const t=this.outFields;if(!(t!=null&&t.length))return this.featureAdapter.getAttributes(e);const r={};for(const a of t){const{alias:i,clause:n}=this._fieldDataCache.get(a);r[i]=n?n.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,i)}return r}_processAttributesForDistinctValues(e){if(e==null||!this.returnDistinctValues)return e;const t=this.outFields,r=[];if(t)for(const n of t){const{alias:l}=this._fieldDataCache.get(n);r.push(e[l])}else for(const n in e)r.push(e[n]);const a=`${(t||["*"]).join(",")}=${r.join(",")}`;let i=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++i),i>1?null:e}};function et(s,e,t){return{objectId:s,target:e,distance:t,type:"vertex"}}function ci(s,e,t,r,a,i=!1){return{objectId:s,target:e,distance:t,type:"edge",start:r,end:a,draped:i}}class A{constructor(e,t,r){this.items=e,this.query=t,this.geometryType=r.geometryType,this.hasM=r.hasM,this.hasZ=r.hasZ,this.fieldsIndex=r.fieldsIndex,this.objectIdField=r.objectIdField,this.spatialReference=r.spatialReference,this.featureAdapter=r.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new ne(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:r,outStatistics:a}=this.query;if(!(t==null?void 0:t.length))return 1;const n=new Map,l=new Map,o=new Set;for(const u of a){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!l.has(h)){const f=[];for(const p of t){const m=this._getAttributeValues(e,p,n);f.push(m)}l.set(h,this._calculateUniqueValues(f,e.returnDistinctValues))}const d=l.get(h);for(const f in d){const{data:p,items:m}=d[f],x=p.join(",");r&&!e.validateItems(m,r)||o.add(x)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics?e=this.query.outStatistics.some(t=>t.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):e=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const t=this.query.geometry;j(this.query.outSR)&&!v(t.spatialReference,this.query.outSR)?e.queryGeometry=K({spatialReference:this.query.outSR,...D(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=K({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const r=this.featureAdapter,a=tt(this.hasZ,this.hasM),{point:i,mode:n}=e,l=typeof e.distance=="number"?e.distance:e.distance.x,o=typeof e.distance=="number"?e.distance:e.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this._getPointCreator(n,this.spatialReference,t),d=new st(null,0),f=new st(null,0),p={x:0,y:0,z:0};for(const m of this.items){const x=r.getGeometry(m);if(x==null)continue;const{coords:y,lengths:E}=x;if(d.coords=y,f.coords=y,e.returnEdge){let S=0;for(let g=0;g<E.length;g++){const _=E[g];for(let R=0;R<_;R++,S+=a){const I=d;if(I.coordsIndex=S,R!==_-1){const F=f;F.coordsIndex=S+a;const w=p;hi(p,i,I,F);const P=(i.x-w.x)/l,se=(i.y-w.y)/o,ie=P*P+se*se;ie<=1&&u.candidates.push(ci(r.getObjectId(m),h(w),Math.sqrt(ie),h(I),h(F)))}}}}if(e.vertexMode!=="none"){const S=c?y.length-a:y.length;if(e.vertexMode==="all")for(let g=0;g<S;g+=a){const _=d;_.coordsIndex=g;const R=(i.x-_.x)/l,I=(i.y-_.y)/o,F=R*R+I*I;F<=1&&u.candidates.push(et(r.getObjectId(m),h(_),Math.sqrt(F)))}else if(e.vertexMode==="ends"){const g=[0];c||g.push(y.length-a);for(const _ of g){const R=d;R.coordsIndex=_;const I=(i.x-R.x)/l,F=(i.y-R.y)/o,w=I*I+F*F;w<=1&&u.candidates.push(et(r.getObjectId(m),h(R),Math.sqrt(w)))}}}}return u.candidates.sort((m,x)=>m.distance-x.distance),u}_getPointCreator(e,t,r){const a=r==null||v(t,r)?l=>l:l=>D(l,t,r),{hasZ:i}=this,n=0;return e==="3d"?i?({x:l,y:o,z:u})=>a({x:l,y:o,z:u}):({x:l,y:o})=>a({x:l,y:o,z:n}):({x:l,y:o})=>a({x:l,y:o})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:r,normalizationField:a,normalizationType:i,normalizationTotal:n,minValue:l,maxValue:o,scale:u,timeZone:c}=e,h=this.fieldsIndex.get(t),d=qe(h)||Ee(h)||Re(h),f=await this._getDataValues({field:t,valueExpression:r,normalizationField:a,normalizationType:i,normalizationTotal:n,scale:u,timeZone:c}),p=js({normalizationType:i,normalizationField:a,minValue:l,maxValue:o}),m={value:.5,fieldType:h==null?void 0:h.type},x=de(h)?He({values:f,supportsNullCount:p,percentileParams:m}):We({values:f,minValue:l,maxValue:o,useSampleStdDev:!i,supportsNullCount:p,percentileParams:m});return Ls(x,d)}async createUniqueValuesResponse(e){const{field:t,valueExpression:r,domains:a,returnAllCodedValues:i,scale:n,timeZone:l}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:r,scale:n,timeZone:l},!1),u=Ms(o);return ks(u,a,i,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:r,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:h,scale:d,timeZone:f}=e,p=await this._getDataValues({field:t,valueExpression:r,normalizationField:a,normalizationType:i,normalizationTotal:n,scale:d,timeZone:f}),m=Vs(p,{field:t,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numClasses:h});return Qs(m,l)}async createHistogramResponse(e){const{field:t,valueExpression:r,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:h,scale:d,timeZone:f}=e,p=await this._getDataValues({field:t,valueExpression:r,normalizationField:a,normalizationType:i,normalizationTotal:n,scale:d,timeZone:f});return Us(p,{field:t,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:l,standardDeviationInterval:o,minValue:u,maxValue:c,numBins:h})}_sortFeatures(e,t,r){if(e.length>1&&(t!=null&&t.length))for(const a of t.reverse()){const i=a.split(" "),n=i[0],l=this.fieldsIndex.get(n),o=!!i[1]&&i[1].toLowerCase()==="desc",u=qs(l==null?void 0:l.type,o);e.sort((c,h)=>{const d=r(c,n,l),f=r(h,n,l);return u(d,f)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:r,hasM:a,hasZ:i,objectIdField:n,spatialReference:l}=this,{outFields:o,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:d,returnZ:f,returnM:p}=e,m=h!=null&&t.length>(d||0)+h,x=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:m,features:this._createFeatures(e,t),fields:x,geometryType:r,hasM:a&&p,hasZ:i&&f,objectIdFieldName:n,spatialReference:K(u||l),transform:c&&ze(c)||null}}_createFeatures(e,t){const r=new ne(e,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:i}=this,{orderByFields:n,quantizationParameters:l,returnGeometry:o,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:d,returnZ:f=!1,returnM:p=!1}=e,m=i&&f,x=a&&p;let y=[],E=0;const S=[...t];if(this._sortFeatures(S,n,(_,R,I)=>r.getFieldValue(_,R,I)),this.geometryType&&(o||u)){const _=ze(l)??void 0,R=this.geometryType==="esriGeometryPolygon"||this.geometryType==="esriGeometryPolyline";if(o&&!u)for(const I of S){const F=this.featureAdapter.getGeometry(I),w={attributes:r.getAttributes(I),geometry:L(this.geometryType,this.hasZ,this.hasM,F,c,_,m,x)};R&&F&&!w.geometry&&(w.centroid=_e(this,this.featureAdapter.getCentroid(I,this),_)),y[E++]=w}else if(!o&&u)for(const I of S)y[E++]={attributes:r.getAttributes(I),centroid:_e(this,this.featureAdapter.getCentroid(I,this),_)};else for(const I of S)y[E++]={attributes:r.getAttributes(I),centroid:_e(this,this.featureAdapter.getCentroid(I,this),_),geometry:L(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(I),c,_,m,x)}}else for(const _ of S){const R=r.getAttributes(_);R&&(y[E++]={attributes:R})}const g=h||0;if(d!=null){const _=g+d;y=y.slice(g,Math.min(y.length,_))}return y}_createExceedsLimitQueryResponse(e){let t=!1,r=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY;for(const n of e.outStatistics??[])if(n.statisticType==="exceedslimit"){r=n.maxPointCount!=null?n.maxPointCount:Number.POSITIVE_INFINITY,a=n.maxRecordCount!=null?n.maxRecordCount:Number.POSITIVE_INFINITY,i=n.maxVertexCount!=null?n.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>r;else if(this.items.length>a)t=!0;else{const n=tt(this.hasZ,this.hasM),l=this.featureAdapter;t=this.items.reduce((o,u)=>{const c=l.getGeometry(u);return o+(c!=null&&c.coords.length||0)},0)/n>i}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){var S;const t={attributes:{}},r=[],a=new Map,i=new Map,n=new Map,l=new Map,o=new ne(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:d,resultRecordCount:f}=e,p=c==null?void 0:c.length,m=!!p,x=m?c[0]:null,y=m&&!this.fieldsIndex.get(x);for(const g of u??[]){const{outStatisticFieldName:_,statisticType:R}=g,I=g,F=R!=="exceedslimit"?g.onStatisticField:void 0,w=R==="percentile_disc"||R==="percentile_cont",P=R==="EnvelopeAggregate"||R==="CentroidAggregate"||R==="ConvexHullAggregate",se=m&&p===1&&(F===x||y)&&R==="count";if(m){if(!n.has(F)){const re=[];for(const he of c){const ae=this._getAttributeValues(o,he,a);re.push(ae)}n.set(F,this._calculateUniqueValues(re,!P&&o.returnDistinctValues))}const M=n.get(F);if(!M)continue;const ce=Object.keys(M);for(const re of ce){const{count:he,data:ae,items:Me,itemPositions:Gt}=M[re],ke=ae.join(",");if(!h||o.validateItems(Me,h)){const Z=l.get(ke)||{attributes:{}};if(P){Z.aggregateGeometries||(Z.aggregateGeometries={});const{aggregateGeometries:k,outStatisticFieldName:W}=await this._getAggregateGeometry(I,Me);Z.aggregateGeometries[W]=k}else{let k=null;if(se)k=he;else{const W=this._getAttributeValues(o,F,a),Ve=Gt.map(Lt=>W[Lt]);k=w&&"statisticParameters"in I?this._getPercentileValue(I,Ve):this._getStatisticValue(I,Ve,null,o.returnDistinctValues)}Z.attributes[_]=k}let Dt=0;c.forEach((k,W)=>Z.attributes[this.fieldsIndex.get(k)?k:"EXPR_"+ ++Dt]=ae[W]),l.set(ke,Z)}}}else if(P){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:M,outStatisticFieldName:ce}=await this._getAggregateGeometry(I,this.items);t.aggregateGeometries[ce]=M}else{const M=this._getAttributeValues(o,F,a);t.attributes[_]=w&&"statisticParameters"in I?this._getPercentileValue(I,M):this._getStatisticValue(I,M,i,o.returnDistinctValues)}const ie=R!=="min"&&R!=="max"||!de(this.fieldsIndex.get(F))&&!this._isAnyDateField(F)?null:(S=this.fieldsIndex.get(F))==null?void 0:S.type;r.push({name:_,alias:_,type:ie||"esriFieldTypeDouble"})}const E=m?Array.from(l.values()):[t];return this._sortFeatures(E,d,(g,_)=>g.attributes[_]),f&&(E.length=Math.min(f,E.length)),{fields:r,features:E}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return qe(t)||Ee(t)||Re(t)||ft(t)}async _getAggregateGeometry(e,t){const{convexHull:r,union:a}=await Pe(()=>import("./geometryEngineWorker-ClddcLz0.js").then(m=>m.g),__vite__mapDeps([0,1,2,3])),{statisticType:i,outStatisticFieldName:n}=e,{featureAdapter:l,spatialReference:o,geometryType:u,hasZ:c,hasM:h}=this,d=t.map(m=>L(u,c,h,l.getGeometry(m))),f=r(o,d,!0)[0],p={aggregateGeometries:null,outStatisticFieldName:null};if(i==="EnvelopeAggregate"){const m=f?zt(f):Se(a(o,d));p.aggregateGeometries={...m,spatialReference:o},p.outStatisticFieldName=n||"extent"}else if(i==="CentroidAggregate"){const m=f?jt(f):Zt(Se(a(o,d)));p.aggregateGeometries={x:m[0],y:m[1],spatialReference:o},p.outStatisticFieldName=n||"centroid"}else i==="ConvexHullAggregate"&&(p.aggregateGeometries=f,p.outStatisticFieldName=n||"convexHull");return p}_getStatisticValue(e,t,r,a){const{onStatisticField:i,statisticType:n}=e;let l=null;return l=r!=null&&r.has(i)?r.get(i):de(this.fieldsIndex.get(i))||this._isAnyDateField(i)?He({values:t,returnDistinct:a}):We({values:a?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),r&&r.set(i,l),l[n==="var"?"variance":n]}_getPercentileValue(e,t){const{onStatisticField:r,statisticParameters:a,statisticType:i}=e,{value:n,orderBy:l}=a,o=this.fieldsIndex.get(r);return zs(t,{value:n,orderBy:l,fieldType:o==null?void 0:o.type,isDiscrete:i==="percentile_disc"})}_getAttributeValues(e,t,r){if(r.has(t))return r.get(t);const a=this.fieldsIndex.get(t),i=this.items.map(n=>e.getFieldValue(n,t,a));return r.set(t,i),i}_calculateUniqueValues(e,t){const r={},a=this.items,i=a.length;for(let n=0;n<i;n++){const l=a[n],o=[];for(const c of e)o.push(c[n]);const u=o.join(",");r[u]==null?r[u]={count:1,data:o,items:[l],itemPositions:[n]}:(t||r[u].count++,r[u].items.push(l),r[u].itemPositions.push(n))}return r}async _getDataValues(e,t=!0){const r=new ne(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:a,scale:i,timeZone:n}=e;return a?r.getExpressionValues(this.items,a,{viewingMode:"map",scale:i,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},n):r.getDataValues(this.items,le(e),t)}}function hi(s,e,t,r){const a=r.x-t.x,i=r.y-t.y,n=a*a+i*i,l=(e.x-t.x)*a+(e.y-t.y)*i,o=Math.min(1,Math.max(0,l/n));s.x=t.x+a*o,s.y=t.y+i*o}function tt(s,e){return s?e?4:3:e?3:2}let st=class{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}};const di=new Bt({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),V=Object.freeze({});async function it(s,e,t){const{outFields:r,orderByFields:a,groupByFieldsForStatistics:i,outStatistics:n}=s;if(r)for(let l=0;l<r.length;l++)r[l]=r[l].trim();if(a)for(let l=0;l<a.length;l++)a[l]=a[l].trim();if(i)for(let l=0;l<i.length;l++)i[l]=i[l].trim();if(n)for(let l=0;l<n.length;l++)n[l].onStatisticField&&(n[l].onStatisticField=n[l].onStatisticField.trim());return s.geometry&&!s.outSR&&(s.outSR=s.geometry.spatialReference),bt(s,e,t)}async function bt(s,e,t){var i;if(!s)return null;let{where:r}=s;if(s.where=r=r==null?void 0:r.trim(),(!r||/^1 *= *1$/.test(r)||e&&e===r)&&(s.where=null),!s.geometry)return s;let a=await mi(s);if(s.distance=0,s.units=null,s.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:n}=s.geometry;a=Se(a),a.spatialReference=n}if(a){await H(a.spatialReference,t),a=fi(a,t);const n=(await be(Fe(a)))[0];if(n==null)throw V;const l="quantizationParameters"in s&&((i=s.quantizationParameters)==null?void 0:i.tolerance)||"maxAllowableOffset"in s&&s.maxAllowableOffset||0,o=l&&At(a,t)?{densificationStep:8*l}:void 0,u=n.toJSON(),c=D(u,u.spatialReference,t,o);if(!c)throw V;c.spatialReference=t,s.geometry=c}return s}function At(s,e){if(!s)return!1;const t=s.spatialReference;return(z(s)||te(s)||Yt(s))&&!v(t,e)&&!Ht(t,e)}function fi(s,e){const t=s.spatialReference;return At(s,e)&&z(s)?{spatialReference:t,rings:[[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]]]}:s}async function mi(s){const{distance:e,units:t}=s,r=s.geometry;if(e==null||"vertexAttributes"in r)return r;const a=r.spatialReference,i=t?di.fromJSON(t):Wt(a),n=a&&(Jt(a)||Oe(a))?r:await H(a,je).then(()=>D(r,je));return(await pi())(n.spatialReference,n,e,i)}async function pi(){return(await Pe(async()=>{const{geodesicBuffer:s}=await import("./geometryEngineWorker-ClddcLz0.js").then(e=>e.g);return{geodesicBuffer:s}},__vite__mapDeps([0,1,2,3]))).geodesicBuffer}function gi(s){return s==="mesh"?Xt:Kt(s)}function Nt(s,e){return s?e?4:3:e?3:2}function yi(s,e,t,r){return $t(s,e,t,r.coords[0],r.coords[1])}function _i(s,e,t,r,a,i){const n=Nt(a,i),{coords:l,lengths:o}=r;if(!o)return!1;for(let u=0,c=0;u<o.length;u++,c+=n)if(!$t(s,e,t,l[c],l[c+1]))return!1;return!0}function $t(s,e,t,r,a){if(!s)return!1;const i=Nt(e,t),{coords:n,lengths:l}=s;let o=!1,u=0;for(const c of l)o=Ii(o,n,i,u,c,r,a),u+=c*i;return o}function Ii(s,e,t,r,a,i,n){let l=s,o=r;for(let u=r,c=r+a*t;u<c;u+=t){o=u+t,o===c&&(o=r);const h=e[u],d=e[u+1],f=e[o],p=e[o+1];(d<n&&p>=n||p<n&&d>=n)&&h+(n-d)/(p-d)*(f-h)<i&&(l=!l)}return l}const Te="unsupported-query",Ti={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},Le={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function xi(s){return s!=null&&Le.spatialRelationship[s]===!0}function Ei(s){return s!=null&&Le.queryGeometry[ss(s)]===!0}function Ri(s){return s!=null&&Le.layerGeometry[s]===!0}function Si(){return Pe(()=>import("./geometryEngineWorker-ClddcLz0.js").then(s=>s.g),__vite__mapDeps([0,1,2,3]))}function J(s,e,t,r,a){if(te(e)&&t==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains")){const i=Ye(new B,e,!1,!1);return Promise.resolve(n=>yi(i,!1,!1,n))}if(te(e)&&t==="esriGeometryMultipoint"){const i=Ye(new B,e,!1,!1);if(s==="esriSpatialRelContains")return Promise.resolve(n=>_i(i,!1,!1,n,r,a))}if(z(e)&&t==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains"))return Promise.resolve(i=>es(e,L(t,r,a,i)));if(z(e)&&t==="esriGeometryMultipoint"&&s==="esriSpatialRelContains")return Promise.resolve(i=>ts(e,L(t,r,a,i)));if(z(e)&&s==="esriSpatialRelIntersects"){const i=gi(t);return Promise.resolve(n=>i(e,L(t,r,a,n)))}return Si().then(i=>{const n=i[Ti[s]].bind(null,e.spatialReference,e);return l=>n(L(t,r,a,l))})}async function vt(s,e,t){var i;const{spatialRel:r,geometry:a}=s;if(a){if(!xi(r))throw new b(Te,"Unsupported query spatial relationship",{query:s});if(j(a.spatialReference)&&j(t)){if(!Ei(a))throw new b(Te,"Unsupported query geometry type",{query:s});if(!Ri(e))throw new b(Te,"Unsupported layer geometry type",{query:s});if(s.outSR)return H((i=s.geometry)==null?void 0:i.spatialReference,s.outSR)}}}function Ct(s){if(z(s))return!0;if(te(s)){for(const e of s.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}const Y="unsupported-query";async function rt(s,{fieldsIndex:e,geometryType:t,spatialReference:r,availableFields:a}){if((s.distance??0)<0||s.geometryPrecision!=null||s.multipatchOption&&s.multipatchOption!=="xyFootprint"||s.pixelSize||s.relationParam||s.text)throw new b(Y,"Unsupported query options",{query:s});return Ot(e,a,s),wi(e,a,s),Promise.all([vt(s,t,r),H(r,s.outSR)]).then(()=>s)}function Ot(s,e,t){const{outFields:r,orderByFields:a,returnDistinctValues:i,outStatistics:n}=t,l=n?n.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(a&&a.length>0){const o=" asc",u=" desc",c=a.map(h=>{const d=h.toLowerCase();return d.includes(o)?d.split(o)[0]:d.includes(u)?d.split(u)[0]:h}).filter(h=>!l.includes(h));Q(s,e,c,{expressionName:"orderByFields",query:t})}if(r&&r.length>0)Q(s,e,r,{expressionName:"outFields",query:t,allowedFieldTypes:"all"});else if(i)throw new b(Y,"outFields should be specified for returnDistinctValues",{query:t});ni(s,e,t.where,t)}const Fi=new Set([...St,...Ft]);function wi(s,e,t){const{outStatistics:r,groupByFieldsForStatistics:a,having:i}=t,n=a==null?void 0:a.length,l=r==null?void 0:r.length;if(i){if(!n||!l)throw new b(Y,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:t});li(s,e,i,r,t)}if(l){if(!Ni(r))return;const o=r.map(u=>u.onStatisticField).filter(Boolean);Q(s,e,o,{expressionName:"onStatisticFields",query:t}),n&&Q(s,e,a,{expressionName:"groupByFieldsForStatistics",query:t});for(const u of r){const{onStatisticField:c,statisticType:h}=u;if((h==="percentile_disc"||h==="percentile_cont")&&"statisticParameters"in u){const{statisticParameters:d}=u;if(!d)throw new b(Y,"statisticParameters should be set for percentile type",{definition:u,query:t})}else s.get(c)&&h!=="count"&&h!=="min"&&h!=="max"&&Q(s,e,[c],{expressionName:`outStatistics with '${h}' statistic type`,allowedFieldTypes:Fi,query:t})}}}async function bi(s,e,{fieldsIndex:t,geometryType:r,spatialReference:a,availableFields:i}){if((s.distance??0)<0||s.geometryPrecision!=null||s.multipatchOption||s.pixelSize||s.relationParam||s.text||s.outStatistics||s.groupByFieldsForStatistics||s.having||s.orderByFields)throw new b(Y,"Unsupported query options",{query:s});return Ot(t,i,s),Promise.all([Ai(t,i,e,s),vt(s,r,a),H(a,s.outSR)]).then(()=>s)}async function Ai(s,e,t,r){let a=[];if(t.valueExpression){const{arcadeUtils:i}=await mt();a=i.extractFieldNames(t.valueExpression)}if(t.field&&a.push(t.field),t.field2&&a.push(t.field2),t.field3&&a.push(t.field3),t.normalizationField&&a.push(t.normalizationField),!a.length&&!t.valueExpression)throw new b(Y,"field or valueExpression is required",{params:t});Q(s,e,a,{expressionName:"statistics",query:r})}function Ni(s){return s!=null&&s.every(e=>e.statisticType!=="exceedslimit")}async function $i(s,e){if(!s)return null;const t=e.featureAdapter,{startTimeField:r,endTimeField:a}=s;let i=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;if(r&&a)await e.forEach(l=>{const o=t.getAttribute(l,r),u=t.getAttribute(l,a);o==null||isNaN(o)||(i=Math.min(i,o)),u==null||isNaN(u)||(n=Math.max(n,u))});else{const l=r||a;await e.forEach(o=>{const u=t.getAttribute(o,l);u==null||isNaN(u)||(i=Math.min(i,u),n=Math.max(n,u))})}return{start:i,end:n}}function vi(s,e,t){var o;if(!e||!s)return null;const{startTimeField:r,endTimeField:a}=s;if(!r&&!a)return null;const{start:i,end:n}=e;if(i===null&&n===null)return null;if(i===void 0&&n===void 0)return Pi();const l=((o=t.getAttributeAsTimestamp)==null?void 0:o.bind(t))??t.getAttribute.bind(t);return r&&a?Ci(l,r,a,i,n):Oi(l,r||a,i,n)}function Ci(s,e,t,r,a){return r!=null&&a!=null?i=>{const n=s(i,e),l=s(i,t);return(n==null||n<=a)&&(l==null||l>=r)}:r!=null?i=>{const n=s(i,t);return n==null||n>=r}:a!=null?i=>{const n=s(i,e);return n==null||n<=a}:void 0}function Oi(s,e,t,r){return t!=null&&r!=null&&t===r?a=>s(a,e)===t:t!=null&&r!=null?a=>{const i=s(a,e);return i!=null&&i>=t&&i<=r}:t!=null?a=>{const i=s(a,e);return i!=null&&i>=t}:r!=null?a=>{const i=s(a,e);return i!=null&&i<=r}:void 0}function Pi(){return()=>!1}const Pt=Symbol("Yield");class Gi{constructor(){this._tasks=new Array,this._runningTasks=$e(0)}get length(){return this._tasks.length}get running(){return this._runningTasks.value>0}destroy(){this.cancelAll()}runTask(e){if(this.length===0)return Pt;for(;!e.done&&this._process(e);)e.madeProgress()}push(e,t,r){return++this._runningTasks.value,new Promise((a,i)=>this._tasks.push(new at(a,i,e,t,r))).finally(()=>--this._runningTasks.value)}unshift(e,t,r){return++this._runningTasks.value,new Promise((a,i)=>this._tasks.unshift(new at(a,i,e,t,r))).finally(()=>--this._runningTasks.value)}_process(e){var r;if(this._tasks.length===0)return!1;const t=this._tasks.shift();try{const a=pt(t.signal);if(a&&!t.abortCallback)t.reject(oe());else{const i=a?(r=t.abortCallback)==null?void 0:r.call(t,oe()):t.callback(e);is(i)?i.then(t.resolve,t.reject):t.resolve(i)}}catch(a){t.reject(a)}return!0}cancelAll(){const e=oe();for(const t of this._tasks)if(t.abortCallback){const r=t.abortCallback(e);t.resolve(r)}else t.reject(e);this._tasks.length=0}}class at{constructor(e,t,r,a=void 0,i=void 0){this.resolve=e,this.reject=t,this.callback=r,this.signal=a,this.abortCallback=i}}let X=class extends as{constructor(){super(...arguments),this.SCHEDULER_LOG_SLOW_TASKS=!1,this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES=!1}};fe([Ze()],X.prototype,"SCHEDULER_LOG_SLOW_TASKS",void 0),fe([Ze()],X.prototype,"FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES",void 0),X=fe([rs("esri.views.support.debugFlags")],X);const Di=new X;var N;(function(s){s[s.ANIMATING=0]="ANIMATING",s[s.INTERACTING=1]="INTERACTING",s[s.IDLE=2]="IDLE"})(N||(N={}));var T;(function(s){s.RESOURCE_CONTROLLER_IMMEDIATE="immediate",s.RESOURCE_CONTROLLER="schedule",s.SLIDE="slide",s.STREAM_DATA_LOADER="stream loader",s.ELEVATION_QUERY="elevation query",s.TERRAIN_SURFACE="terrain",s.SURFACE_GEOMETRY_UPDATES="surface geometry updates",s.LOD_RENDERER="LoD renderer",s.GRAPHICS_CORE="Graphics3D",s.I3S_CONTROLLER="I3S",s.POINT_CLOUD_LAYER="point cloud",s.FEATURE_TILE_FETCHER="feature fetcher",s.OVERLAY="overlay",s.STAGE="stage",s.GRAPHICS_DECONFLICTOR="graphics deconflictor",s.FILTER_VISIBILITY="Graphics3D filter visibility",s.SCALE_VISIBILITY="Graphics3D scale visibility",s.FRUSTUM_VISIBILITY="Graphics3D frustum visibility",s.POINT_OF_INTEREST_FREQUENT="POI frequent",s.POINT_OF_INTEREST_INFREQUENT="POI infrequent",s.LABELER="labeler",s.FEATURE_QUERY_ENGINE="feature query",s.FEATURE_TILE_TREE="feature tile tree",s.FEATURE_TILE_TREE_ACTIVE="fast feature tile tree",s.ELEVATION_ALIGNMENT="elevation alignment",s.ELEVATION_ALIGNMENT_SCENE="elevation alignment scene",s.TEXT_TEXTURE_ATLAS="text texture atlas",s.TEXTURE_UNLOAD="texture unload",s.LINE_OF_SIGHT_TOOL="line of sight tool",s.LINE_OF_SIGHT_TOOL_INTERACTIVE="interactive line of sight tool",s.ELEVATION_PROFILE="elevation profile",s.SNAPPING="snapping",s.SHADOW_ACCUMULATOR="shadow accumulator",s.CLOUDS_GENERATOR="clouds generator",s[s.NONE=0]="NONE",s[s.TEST_PRIO=1]="TEST_PRIO"})(T||(T={}));const O=0,nt=new Map([[T.RESOURCE_CONTROLLER_IMMEDIATE,O],[T.RESOURCE_CONTROLLER,4],[T.SLIDE,O],[T.STREAM_DATA_LOADER,O],[T.ELEVATION_QUERY,O],[T.TERRAIN_SURFACE,1],[T.SURFACE_GEOMETRY_UPDATES,1],[T.LOD_RENDERER,2],[T.GRAPHICS_CORE,2],[T.I3S_CONTROLLER,2],[T.POINT_CLOUD_LAYER,2],[T.FEATURE_TILE_FETCHER,2],[T.OVERLAY,4],[T.STAGE,4],[T.GRAPHICS_DECONFLICTOR,4],[T.FILTER_VISIBILITY,4],[T.SCALE_VISIBILITY,4],[T.FRUSTUM_VISIBILITY,4],[T.CLOUDS_GENERATOR,4],[T.POINT_OF_INTEREST_FREQUENT,6],[T.POINT_OF_INTEREST_INFREQUENT,30],[T.LABELER,8],[T.FEATURE_QUERY_ENGINE,8],[T.FEATURE_TILE_TREE,16],[T.FEATURE_TILE_TREE_ACTIVE,O],[T.ELEVATION_ALIGNMENT,12],[T.ELEVATION_ALIGNMENT_SCENE,14],[T.TEXT_TEXTURE_ATLAS,12],[T.TEXTURE_UNLOAD,12],[T.LINE_OF_SIGHT_TOOL,16],[T.LINE_OF_SIGHT_TOOL_INTERACTIVE,O],[T.SNAPPING,O],[T.SHADOW_ACCUMULATOR,30]]);function lt(s){return nt.has(s)?nt.get(s):typeof s=="number"?s:1}const Li=C(6.5),ot=C(1),Mi=C(30),ki=C(1e3/30),Vi=C(100),ut=.9;var Ce,U;(function(s){class e{get updating(){return this._updating.value}_updatingChanged(){this._updating.value=this._tasks.some(i=>i.needsUpdate)}constructor(){this._updating=$e(!0),this._microTaskQueued=!1,this._frameNumber=0,this.performanceInfo={total:new me("total"),tasks:new Map},this._frameTaskTimes=new Map,this._budget=new r,this._state=N.INTERACTING,this._tasks=new pe,this._runQueue=new pe,this._load=0,this._idleStateCallbacks=new pe,this._idleUpdatesStartFired=!1,this._forceTask=!1,this._debug=!1,this._debugHandle=ns(()=>Di.SCHEDULER_LOG_SLOW_TASKS,i=>this._debug=i,ls);for(const i of Object.keys(T))this.performanceInfo.tasks.set(T[i],new me(T[i]))}destroy(){this._tasks.toArray().forEach(i=>i.remove()),this._tasks.clear(),we(this._debugHandle),this._microTaskQueued=!1,this._updatingChanged()}taskRunningChanged(i){this._updatingChanged(),i&&this._budget.remaining>0&&!this._microTaskQueued&&(this._microTaskQueued=!0,queueMicrotask(()=>{this._microTaskQueued&&(this._microTaskQueued=!1,this._budget.remaining>0&&this._schedule()&&this.frame())}))}registerTask(i,n){const l=new t(this,i,n);return this._tasks.push(l),this._updatingChanged(),this.performanceInfo.tasks.has(i)||this.performanceInfo.tasks.set(i,new me(i)),l}registerIdleStateCallbacks(i,n){const l={idleBegin:i,idleEnd:n};this._idleStateCallbacks.push(l),this.state===N.IDLE&&this._idleUpdatesStartFired&&l.idleBegin();const o=this;return{remove:()=>this._removeIdleStateCallbacks(l),set idleBegin(u){o._idleUpdatesStartFired&&(l.idleEnd(),o._state===N.IDLE&&u()),l.idleBegin=u},set idleEnd(u){l.idleEnd=u}}}get load(){return this._load}set state(i){this._state!==i&&(this._state=i,this.state!==N.IDLE&&this._idleUpdatesStartFired&&(this._idleUpdatesStartFired=!1,this._idleStateCallbacks.forAll(n=>n.idleEnd())))}get state(){return this._state}updateBudget(i){++this._frameNumber;let n=Li,l=i.frameDuration,o=ot;switch(this.state){case N.IDLE:n=C(0),l=C(Math.max(Vi,i.frameDuration)),o=Mi;break;case N.INTERACTING:l=C(Math.max(ki,i.frameDuration));case N.ANIMATING:}return l=C(l-i.elapsedFrameTime-n),this.state!==N.IDLE&&l<ot&&!this._forceTask?(this._forceTask=!0,!1):(l=C(Math.max(l,o)),this._budget.reset(l,this.state),this._updateLoad(),this._schedule())}frame(){switch(this._forceTask=!1,this._microTaskQueued=!1,this.state){case N.IDLE:this._idleUpdatesStartFired||(this._idleUpdatesStartFired=!0,this._idleStateCallbacks.forAll(i=>i.idleBegin())),this._runIdle();break;case N.INTERACTING:this._runInteracting();break;default:this._runAnimating()}}stopFrame(){this._budget.reset(C(0),this._state),this._budget.madeProgress()}_removeIdleStateCallbacks(i){this._idleUpdatesStartFired&&i.idleEnd(),this._idleStateCallbacks.removeUnordered(i)}removeTask(i){this._tasks.removeUnordered(i),this._runQueue.removeUnordered(i),this._updatingChanged()}_updateTask(i){this._tasks.forAll(n=>{n.name===i&&n.setPriority(i)})}_getState(i){if(this._runQueue.some(l=>l.name===i))return U.SCHEDULED;let n=U.IDLE;return this._tasks.forAll(l=>{l.name===i&&l.needsUpdate&&(l.schedulePriority<=1?n=U.READY:n!==U.READY&&(n=U.WAITING))}),n}_getRuntime(i){let n=0;return this._tasks.forAll(l=>{l.name===i&&(n+=l.runtime)}),n}_resetRuntimes(){this._tasks.forAll(i=>i.runtime=0)}_getRunning(){const i=new Map;if(this._tasks.forAll(l=>{l.needsUpdate&&i.set(l.name,(i.get(l.name)||0)+1)}),i.size===0)return null;let n="";return i.forEach((l,o)=>{n+=l>1?` ${l}x ${o}`:` ${o}`}),n}_runIdle(){this._run()}_runInteracting(){this._run()}_runAnimating(){this._run()}_updateLoad(){const i=this._tasks.reduce((n,l)=>l.needsUpdate?++n:n,0);this._load=this._load*ut+i*(1-ut)}_schedule(){for(this._runQueue.filterInPlace(i=>!!i.needsUpdate||(i.schedulePriority=i.basePriority,!1)),this._tasks.forAll(i=>{i.basePriority===O&&i.needsUpdate&&!this._runQueue.includes(i)&&i.blockFrame!==this._frameNumber&&this._runQueue.unshift(i)});this._runQueue.length===0;){let i=!1,n=0;if(this._tasks.forAll(l=>{l.needsUpdate&&l.schedulePriority!==0&&l.basePriority!==O&&l.blockFrame!==this._frameNumber&&(i=!0,n=Math.max(n,l.basePriority),l.schedulePriority===1?(l.schedulePriority=0,this._runQueue.push(l)):--l.schedulePriority)}),!i)return this._updatingChanged(),!1}return this._updatingChanged(),!0}_run(){const i=this._budget.now();this._startFrameTaskTimes();do for(;this._runQueue.length>0;){const n=this._budget.now(),l=this._runQueue.pop();this._budget.resetProgress();try{l.task.runTask(this._budget)===Pt&&(l.blockFrame=this._frameNumber)}catch(u){os.getLogger("esri.views.support.Scheduler").error(`Exception in task "${l.name}"`,u),l.blockFrame=this._frameNumber}!this._budget.hasProgressed&&l.blockFrame!==this._frameNumber&&l.needsUpdate&&(l.name,T.I3S_CONTROLLER,l.blockFrame=this._frameNumber),l.schedulePriority=l.basePriority;const o=this._budget.now()-n;if(l.runtime+=o,this._frameTaskTimes.set(l.priority,this._frameTaskTimes.get(l.priority)+o),this._budget.remaining<=0)return this._updatingChanged(),void this._recordFrameTaskTimes(this._budget.now()-i)}while(this._schedule());this._updatingChanged(),this._recordFrameTaskTimes(this._budget.now()-i)}_startFrameTaskTimes(){for(const i of Object.keys(T))this._frameTaskTimes.set(T[i],0)}_recordFrameTaskTimes(i){this._frameTaskTimes.forEach((n,l)=>this.performanceInfo.tasks.get(l).record(n)),this.performanceInfo.total.record(i)}get test(){}}s.Scheduler=e;class t{get task(){return this._task.value}get updating(){return this._queue.running}constructor(i,n,l){this._scheduler=i,this.name=n,this.blockFrame=0,this.runtime=0,this._queue=new Gi,this._handles=new us,this._basePriority=lt(n),this.schedulePriority=this._basePriority,this._task=$e(l??this._queue),this._handles.add(cs(()=>this.task.running,o=>i.taskRunningChanged(o)))}remove(){this.processQueue(ue),this._scheduler.removeTask(this),this.schedule=ct.schedule,this.reschedule=ct.reschedule,this._handles.destroy()}get basePriority(){return this._basePriority}setPriority(i){if(this.name===i)return;this.name=i;const n=lt(i);this._basePriority!==O&&this.schedulePriority===0||(this.schedulePriority=n),this._basePriority=n}get priority(){return this.name}set priority(i){this.setPriority(i)}get needsUpdate(){return this.updating||this.task.running}schedule(i,n,l){return this._queue.push(i,n,l)}reschedule(i,n,l){return this._queue.unshift(i,n,l)}processQueue(i){return this._queue.runTask(i)}}class r{constructor(){this._begin=typeof performance<"u"?performance.now():0,this._budget=0,this._state=N.IDLE,this._done=!1,this._progressed=!1,this._enabled=!0}run(i){return!this.done&&(i()===!0&&this.madeProgress(),!0)}get done(){return this._done}get budget(){return this._budget}madeProgress(){return this._progressed=!0,this._done=this.elapsed>=this._budget&&this._enabled,this._done}get state(){return this._state}get enabled(){return this._enabled}set enabled(i){this._enabled=i}reset(i,n){this._begin=this.now(),this._budget=i,this._state=n,this.resetProgress()}get remaining(){return Math.max(this._budget-this.elapsed,0)}now(){return performance.now()}get elapsed(){return this.now()-this._begin}resetProgress(){this._progressed=!1,this._done=!1}get hasProgressed(){return this._progressed}}s.Budget=r})(Ce||(Ce={})),function(s){s.SCHEDULED="s",s.READY="r",s.WAITING="w",s.IDLE="i"}(U||(U={}));const ue=(()=>{const s=new Ce.Budget;return s.enabled=!1,s})();class Qi{remove(){}processQueue(){}schedule(e,t,r){try{if(pt(t)){const a=oe();return r?Promise.resolve(r(a)):Promise.reject(a)}return hs(e(ue))}catch(a){return Promise.reject(a)}}reschedule(e,t,r){return this.schedule(e,t,r)}}const ct=new Qi,Ui="unsupported-query",qi=new ds(2e6);let zi=0;class ar{constructor(e){this._geometryQueryCache=null,this._changeHandle=null,this.capabilities={query:Ps},this.geometryType=e.geometryType,this.hasM=!!e.hasM,this.hasZ=!!e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new fs(zi+++"$$",qi)),this.fieldsIndex=ms(e.fieldsIndex)?e.fieldsIndex:ps.fromJSON(e.fieldsIndex),!e.availableFields||e.availableFields.length===1&&e.availableFields[0]==="*"?this.availableFields=new Set(this.fieldsIndex.fields.map(t=>t.name)):this.availableFields=new Set(e.availableFields.map(t=>{var r;return(r=this.fieldsIndex.get(t))==null?void 0:r.name}).filter(t=>t!=null)),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=we(this._frameTask),this.clearCache(),gs(this._geometryQueryCache),this._changeHandle=we(this._changeHandle)}get featureAdapter(){return this.featureStore.featureAdapter}clearCache(){var e;(e=this._geometryQueryCache)==null||e.clear(),this._allFeaturesPromise=null,this._timeExtentPromise=null,this._fullExtentPromise=null}async executeQuery(e,t){const r=$(t);try{return(await this._executeQuery(e,{},r)).createQueryResponse()}catch(a){if(a!==V)throw a;return new A([],e,this).createQueryResponse()}}async executeQueryForCount(e={},t){const r=$(t);try{return(await this._executeQuery(e,{returnGeometry:!1,returnCentroid:!1,outSR:null},r)).createQueryResponseForCount()}catch(a){if(a!==V)throw a;return 0}}async executeQueryForExtent(e,t){const r=$(t),a=e.outSR;try{const i=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},r),n=i.size;return n?{count:n,extent:await this._getBounds(i.items,i.spatialReference,a||this.spatialReference)}:{count:0,extent:null}}catch(i){if(i===V)return{count:0,extent:null};throw i}}async executeQueryForIds(e,t){return this.executeQueryForIdSet(e,t).then(r=>Array.from(r))}async executeQueryForIdSet(e,t){const r=$(t);try{const a=await this._executeQuery(e,{returnGeometry:!0,returnCentroid:!1,outSR:null},r),i=a.items,n=new Set;return await this._reschedule(()=>{for(const l of i)n.add(a.featureAdapter.getObjectId(l))},r),n}catch(a){if(a===V)return new Set;throw a}}async executeQueryForSnapping(e,t){const r=$(t),{point:a,distance:i,returnEdge:n,vertexMode:l}=e;if(!n&&l==="none")return{candidates:[]};let o=le(e.query);o=await this._schedule(()=>bt(o,this.definitionExpression,this.spatialReference),r),o=await this._reschedule(()=>rt(o,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),r);const u=!v(a.spatialReference,this.spatialReference);u&&await H(a.spatialReference,this.spatialReference);const c=typeof i=="number"?i:i.x,h=typeof i=="number"?i:i.y,d={xmin:a.x-c,xmax:a.x+c,ymin:a.y-h,ymax:a.y+h,spatialReference:a.spatialReference},f=u?D(d,this.spatialReference):d;if(!f)return{candidates:[]};const p=(await be(Fe(a),null,{signal:r}))[0],m=(await be(Fe(f),null,{signal:r}))[0];if(p==null||m==null)return{candidates:[]};const x=new A(await this._reschedule(()=>this._searchFeatures(xe(m.toJSON())),r),o,this);await this._reschedule(()=>this._executeObjectIdsQuery(x),r),await this._reschedule(()=>this._executeTimeQuery(x),r),await this._reschedule(()=>this._executeAttributesQuery(x),r),await this._reschedule(()=>this._executeGeometryQueryForSnapping(x,r),r);const y=p.toJSON(),E=u?D(y,this.spatialReference):y,S=u?Math.max(f.xmax-f.xmin,f.ymax-f.ymin)/2:i;return x.createSnappingResponse({...e,point:E,distance:S},a.spatialReference)}async executeQueryForLatestObservations(e,t){var a;const r=$(t);if(!((a=this.timeInfo)!=null&&a.trackIdField))throw new b(Ui,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});try{const i=await this._executeQuery(e,{},r);return await this._reschedule(()=>this._filterLatest(i),r),i.createQueryResponse()}catch(i){if(i!==V)throw i;return new A([],e,this).createQueryResponse()}}async executeQueryForSummaryStatistics(e={},t,r){const a=$(r),{field:i,normalizationField:n,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:i,normalizationField:n,valueExpression:l},a)).createSummaryStatisticsResponse(t)}async executeQueryForUniqueValues(e={},t,r){const a=$(r),{field:i,field2:n,field3:l,valueExpression:o}=t;return(await this._executeQueryForStatistics(e,{field:i,field2:n,field3:l,valueExpression:o},a)).createUniqueValuesResponse(t)}async executeQueryForClassBreaks(e={},t,r){const a=$(r),{field:i,normalizationField:n,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:i,normalizationField:n,valueExpression:l},a)).createClassBreaksResponse(t)}async executeQueryForHistogram(e={},t,r){const a=$(r),{field:i,normalizationField:n,valueExpression:l}=t;return(await this._executeQueryForStatistics(e,{field:i,normalizationField:n,valueExpression:l},a)).createHistogramResponse(t)}async fetchRecomputedExtents(e){const t=$(e);this._timeExtentPromise||(this._timeExtentPromise=$i(this.timeInfo,this.featureStore));const[r,a]=await Promise.all([this._getFullExtent(),this._timeExtentPromise]);return ys(t),{fullExtent:r,timeExtent:a}}async _getBounds(e,t,r){const a=_s(Is(),Fs);await this.featureStore.forEachBounds(e,l=>Ts(a,l));const i={xmin:a[0],ymin:a[1],xmax:a[3],ymax:a[4],spatialReference:K(this.spatialReference)};this.hasZ&&isFinite(a[2])&&isFinite(a[5])&&(i.zmin=a[2],i.zmax=a[5],i.hasZ=!0);const n=D(i,t,r);if(n.spatialReference=K(r),n.xmax-n.xmin==0){const l=ge(n.spatialReference);n.xmin-=l,n.xmax+=l}if(n.ymax-n.ymin==0){const l=ge(n.spatialReference);n.ymin-=l,n.ymax+=l}if(this.hasZ&&n.zmin!=null&&n.zmax!=null&&n.zmax-n.zmin==0){const l=ge(n.spatialReference);n.zmin-=l,n.zmax+=l}return n}_getFullExtent(){return this._fullExtentPromise||(this._fullExtentPromise="getFullExtent"in this.featureStore&&this.featureStore.getFullExtent?Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)):this._getAllFeatures().then(e=>this._getBounds(e,this.spatialReference,this.spatialReference))),this._fullExtentPromise}async _schedule(e,t){return this._frameTask!=null?this._frameTask.schedule(e,t):e(ue)}async _reschedule(e,t){return this._frameTask!=null?this._frameTask.reschedule(e,t):e(ue)}async _getAllFeaturesQueryEngineResult(e){return new A(await this._getAllFeatures(),e,this)}async _getAllFeatures(){if(this._allFeaturesPromise==null){const r=[];this._allFeaturesPromise=(async()=>{await this.featureStore.forEach(a=>r.push(a))})().then(()=>r)}const e=this._allFeaturesPromise,t=await e;return e===this._allFeaturesPromise?t.slice():this._getAllFeatures()}async _executeQuery(e,t,r){e=le(e),e=await this._schedule(()=>it(e,this.definitionExpression,this.spatialReference),r),e=await this._reschedule(()=>rt(e,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),r),e={...e,...t};const a=await this._reschedule(()=>this._executeSceneFilterQuery(e,r),r),i=await this._reschedule(()=>this._executeGeometryQuery(e,a,r),r);return await this._reschedule(()=>this._executeAggregateIdsQuery(i),r),await this._reschedule(()=>this._executeObjectIdsQuery(i),r),await this._reschedule(()=>this._executeTimeQuery(i),r),await this._reschedule(()=>this._executeAttributesQuery(i),r),i}async _executeSceneFilterQuery(e,t){if(e.sceneFilter==null)return null;const{outSR:r,returnGeometry:a,returnCentroid:i}=e,n=this.featureStore.featureSpatialReference,l=e.sceneFilter.geometry,o=n==null||v(n,l.spatialReference)?l:D(l,n);if(!o)return null;const u=a||i,c=j(r)&&!v(this.spatialReference,r)&&u?async m=>this._project(m,r):m=>m,h=this.featureAdapter,d=await this._reschedule(()=>this._searchFeatures(xe(o)),t);if(e.sceneFilter.spatialRelationship==="disjoint"){if(!d.length)return null;const m=new Set;for(const E of d)m.add(h.getObjectId(E));const x=await this._reschedule(()=>this._getAllFeatures(),t),y=await this._reschedule(async()=>{const E=await J("esriSpatialRelDisjoint",o,this.geometryType,this.hasZ,this.hasM),S=_=>!m.has(h.getObjectId(_))||E(h.getGeometry(_)),g=await this._runSpatialFilter(x,S,t);return new A(g,e,this)},t);return c(y)}if(!d.length)return new A([],e,this);if(this._canExecuteSinglePass(o,e))return c(new A(d,e,this));const f=await J("esriSpatialRelContains",o,this.geometryType,this.hasZ,this.hasM),p=await this._runSpatialFilter(d,m=>f(h.getGeometry(m)),t);return c(new A(p,e,this))}async _executeGeometryQuery(e,t,r){if(t!=null&&t.items.length===0)return t;e=t!=null?t.query:e;const{geometry:a,outSR:i,spatialRel:n,returnGeometry:l,returnCentroid:o}=e,u=this.featureStore.featureSpatialReference,c=!a||u==null||v(u,a.spatialReference)?a:D(a,u),h=l||o,d=j(i)&&!v(this.spatialReference,i),f=this._geometryQueryCache&&t==null?JSON.stringify(d&&h?{originalFilterGeometry:a,spatialRelationship:n,outSpatialReference:i}:{originalFilterGeometry:a,spatialRelationship:n}):null,p=f?this._geometryQueryCache.get(f):null;if(p!=null)return new A(p,e,this);const m=async g=>(d&&h&&await this._project(g,i),f&&this._geometryQueryCache.put(f,g.items,g.items.length+1),g);if(!c)return m(t??await this._getAllFeaturesQueryEngineResult(e));const x=this.featureAdapter;let y=await this._reschedule(()=>this._searchFeatures(xe(a)),r);if(n==="esriSpatialRelDisjoint"){if(!y.length)return m(t??await this._getAllFeaturesQueryEngineResult(e));const g=new Set;for(const I of y)g.add(x.getObjectId(I));const _=t!=null?t.items:await this._reschedule(()=>this._getAllFeatures(),r),R=await this._reschedule(async()=>{const I=await J(n,c,this.geometryType,this.hasZ,this.hasM),F=P=>!g.has(x.getObjectId(P))||I(x.getGeometry(P)),w=await this._runSpatialFilter(_,F,r);return new A(w,e,this)},r);return m(R)}if(t!=null){const g=new ws;y=y.filter(_=>xs(t.items,_,t.items.length,g)>=0)}if(!y.length){const g=new A([],e,this);return f&&this._geometryQueryCache.put(f,g.items,1),g}if(this._canExecuteSinglePass(c,e))return m(new A(y,e,this));const E=await J(n,c,this.geometryType,this.hasZ,this.hasM),S=await this._runSpatialFilter(y,g=>E(x.getGeometry(g)),r);return m(new A(S,e,this))}async _executeGeometryQueryForSnapping(e,t){var l;const{query:r}=e,{spatialRel:a}=r;if(!((l=e==null?void 0:e.items)!=null&&l.length)||!r.geometry||!a)return;const i=await J(a,r.geometry,this.geometryType,this.hasZ,this.hasM),n=await this._runSpatialFilter(e.items,o=>i(o.geometry),t);e.items=n}_executeAggregateIdsQuery(e){var a;if(e.items.length===0||!((a=e.query.aggregateIds)!=null&&a.length)||this.aggregateAdapter==null)return;const t=new Set;for(const i of e.query.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach(n=>t.add(n));const r=this.featureAdapter.getObjectId;e.items=e.items.filter(i=>t.has(r(i)))}_executeObjectIdsQuery(e){var a;if(e.items.length===0||!((a=e.query.objectIds)!=null&&a.length))return;const t=new Set(e.query.objectIds),r=this.featureAdapter.getObjectId;e.items=e.items.filter(i=>t.has(r(i)))}_executeTimeQuery(e){if(e.items.length===0)return;const t=vi(this.timeInfo,e.query.timeExtent,this.featureAdapter);t!=null&&(e.items=e.items.filter(t))}_executeAttributesQuery(e){if(e.items.length===0)return;const t=q(e.query.where,this.fieldsIndex);if(t){if(!t.isStandardized)throw new TypeError("Where clause is not standardized");e.items=e.items.filter(r=>t.testFeature(r,this.featureAdapter))}}async _runSpatialFilter(e,t,r){if(!t)return e;if(this._frameTask==null)return e.filter(l=>t(l));let a=0;const i=new Array,n=async l=>{for(;a<e.length;){const o=e[a++];t(o)&&(i.push(o),l.madeProgress()),l.done&&await this._reschedule(u=>n(u),r)}};return this._reschedule(l=>n(l),r).then(()=>i)}_filterLatest(e){const{trackIdField:t,startTimeField:r,endTimeField:a}=this.timeInfo,i=a||r,n=new Map,l=this.featureAdapter.getAttribute;for(const o of e.items){const u=l(o,t),c=l(o,i),h=n.get(u);(!h||c>l(h,i))&&n.set(u,o)}e.items=Array.from(n.values())}_canExecuteSinglePass(e,t){const{spatialRel:r}=t;return Ct(e)&&(r==="esriSpatialRelEnvelopeIntersects"||this.geometryType==="esriGeometryPoint"&&(r==="esriSpatialRelIntersects"||r==="esriSpatialRelContains"))}async _project(e,t){if(!t||v(this.spatialReference,t))return e;const r=this.featureAdapter;let a;try{const n=await this._getFullExtent();a=Es(this.spatialReference,t,n)}catch{}const i=await ii(e.items.map(n=>L(this.geometryType,this.hasZ,this.hasM,r.getGeometry(n))),this.spatialReference,t,a);return e.items=i.map((n,l)=>r.cloneWithGeometry(e.items[l],Cs(n,this.hasZ,this.hasM))),e}async _searchFeatures(e){const t=new Set;await Promise.all(e.map(a=>this.featureStore.forEachInBounds(a,i=>t.add(i))));const r=Array.from(t.values());return t.clear(),r}async _executeQueryForStatistics(e,t,r){e=le(e);try{e=await this._schedule(()=>it(e,this.definitionExpression,this.spatialReference),r),e=await this._reschedule(()=>bi(e,t,{availableFields:this.availableFields,fieldsIndex:this.fieldsIndex,geometryType:this.geometryType,spatialReference:this.spatialReference}),r);const a=await this._reschedule(()=>this._executeSceneFilterQuery(e,r),r),i=await this._reschedule(()=>this._executeGeometryQuery(e,a,r),r);return await this._reschedule(()=>this._executeAggregateIdsQuery(i),r),await this._reschedule(()=>this._executeObjectIdsQuery(i),r),await this._reschedule(()=>this._executeTimeQuery(i),r),await this._reschedule(()=>this._executeAttributesQuery(i),r),i}catch(a){if(a!==V)throw a;return new A([],e,this)}}}function xe(s){if(Ct(s)){if(z(s))return[Be(Math.min(s.xmin,s.xmax),Math.min(s.ymin,s.ymax),Math.max(s.xmin,s.xmax),Math.max(s.ymin,s.ymax))];if(te(s))return s.rings.map(e=>Be(Math.min(e[0][0],e[2][0]),Math.min(e[0][1],e[2][1]),Math.max(e[0][0],e[2][0]),Math.max(e[0][1],e[2][1])))}return[Rs(Ss(),s)]}export{ar as $,bt as a,K as h,D as j,Ys as n,tr as o,vi as t,J as v,H as x};
